<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {background-color: Silver;}
</style>
<body>
<script type="text/javascript" src="http://d3js.org/d3.v2.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script>

// Set up SVG
var width = 960,
    height = 500;

var svg = d3.select("body").append("svg:svg")
    .attr("width", width)
    .attr("height", height);

// Get asynchronous data.
// Load customization first, because it's likely to be smaller; then load P5. <- is this good?
d3.json("testdata/odd.json", function(odd) {
    d3.json("testdata/p5.json", function(p5) {
        
        // Interpolating data to understand the customization...
        
        // Modules
        TEImodules = p5.modules;
        moduleRefs = odd.moduleRefs;

        // get modules not referenced
        var modules = TEImodules.filter(function(e, i) {
            for (var j = 0; j < moduleRefs.length; j++) {
                if (e.ident == moduleRefs[j].key) {
                  return 0
                }
            } 
            return 1
        });

        // add the refs
        modules.push.apply(modules, moduleRefs);

        modules.sort(function(a,b){
            nameA = a.ident===undefined ? a.key : a.ident
            nameB = b.ident===undefined ? b.key : b.ident
            // first sort by type, then sort alphabetically
            // TODO: Put added in the middle
            if ((a.ident===undefined && b.ident===undefined) || 
                (a.ident!==undefined && b.ident!==undefined)) {
                if (nameA > nameB) {
                    return 1;
                }
                else {return -1}
            }
            else if (a.ident===undefined){return -1;}
            else {return 1;}
            return 0;
        });

        // Finally, create a simplified list of active modules. 
        active_modules = [];
        for (var i = 0; i < modules.length; i++) {
            if (modules[i].key!==undefined) active_modules.push(modules[i].key);
        }

        // Classes
        TEIclasses = p5.modelclasses;
        classRefs = odd.classRefs;
        
        classes = [];
        for (var i = 0; i < TEIclasses.length; i++) {
            classes.push(TEIclasses[i]);
            if (active_modules.indexOf(TEIclasses[i].module) != -1) {
                classes[classes.indexOf(TEIclasses[i])].include = 'yes';
            }
        }

        // Create a simplified list of active classes so far. 
        active_classes = [];
        for (var i = 0; i < classes.length; i++) {
            if (classes[i].key!==undefined) {active_classes.push(classes[i].key)}
            else if (classes[i].include!==undefined) {active_classes.push(classes[i].ident)}
        }

        // If references are part of an already referenced module, flag them.
        for (var i = 0; i < classRefs.length; i++) {
            if (active_classes.indexOf(classRefs[i].key) != -1) {
                classRefs[i].flag = 'Already included';
            }
        }
        
        // add the refs
        classes.push.apply(classes, classRefs);

        classes.sort(function(a,b){
            // first sort by type, then sort alphabetically
            if ((a.include===undefined && b.include===undefined) ||
                (a.include!==undefined && b.include!==undefined)) {
                if (a.ident > a.ident) {
                    return 1;
                }
                else {return 0}
            }
            else if (a.include===undefined){return 1;}
            else {return 0;}
            return 0;
        });

        // Macros
        TEImacros = p5.macros;
        ODDmacros = odd.macros
        macroRefs = odd.macroRefs;
        
        macros = [];
        
        for (var i = 0; i < TEImacros.length; i++) {
            macros.push(TEImacros[i]);
            // Include if part of included modules
            for (var j = 0; j < modules.length; j++) {
                if (modules[j].key!==undefined) {
                  if (TEImacros[i].module == modules[j].key) {
                    macros[macros.indexOf(TEImacros[i])].include = 'yes';
                  }
                }
            }
            for (var x = 0; x < ODDmacros.length; x++) {
                if (TEImacros[i].ident==ODDmacros[x].ident) {
                    // The macro is overriden in ODD? Replace it.
                    macros.splice(macros.indexOf(TEImacros[i]), 1);
                    macros.push(ODDmacros[x]);
                }
                // New macro
                else if (ODDmacros[x].mode=='add') {
                    macros.push(ODDmacros[x]);
                }
            }
            // Add Refs
            /*for (var y = 0; y < macroRefs.length; y++) {
                if (macroRefs[y].key == TEImacros[i].ident) {
                    // if it's from an arleady included module, flag it with a warning.
                    for (var m = 0; m < modules.length; m++) {
                        if (modules[m].key!==undefined) {
                          if (macroRefs[y].module == modules[m].key) {
                            macroRefs[y].warning = 'Referenced macro is already included.';
                          }
                        }
                    }
                    macros.push(macroRefs[y]);
                }            
            }*/
        }

        // Now let's plot this, etc.

        // Set scale for module data
        var modules_x = d3.scale.linear()
        .domain([0, modules.length])
        .range([0, width]); 

        modulesBar = svg.selectAll("rect.modules")
            .data(modules)
          .enter().append("svg:rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", width/modules.length-2)
            .attr("height", 100)
            .attr("title", function(d) {return d.key!==undefined ? d.key : d.ident})
            .attr("fill", function(d) {return paint(d)})
            .on("mouseover", onMouseOver)
            .on("mouseout", function(){d3.select(this).style("stroke-width", "0");})
          .transition()
            .delay(100)
            .duration(1000) 
            .attr("x", function(d, i) {return modules_x(i);});

        // Set scale for module data
        var classes_x = d3.scale.linear()
        .domain([0, classes.length])
        .range([0, width]); 

        classesBar = svg.selectAll("rect.classes")
            .data(classes)
          .enter().append("svg:rect")
            .attr("x", 0)
            .attr("y", 110)
            .attr("width",  width/classes.length-2)
            .attr("height", 100)
            .attr("title", function(d) {return d.key!==undefined ? d.key : d.ident})
            .attr("fill", function(d) {return paint(d)})
            .on("mouseover", onMouseOver)
            .on("mouseout", function(){d3.select(this).style("stroke-width", "0");})
          .transition()
            .delay(100)
            .duration(1000) 
            .attr("x", function(d, i) {return classes_x(i);});

    });
});

var onMouseOver = function(d){
    obj = d3.select(this);

    obj.style("stroke-width", "3"); 
    obj.style("stroke", colors.selected);
    // Find a way to put a tooltip here?
} 

var colors = {
    'add' : 'Cyan',
    'change' : 'Orange',
    'delete' : 'Red',
    'included' : '#90EE90',
    'excluded' : 'White',
    'selected' : '#5F9EA0',
    'warning' : 'Yellow',
}

var paint = function(d) {
        //a definition
        if (d.key===undefined && d.include===undefined) {return colors.excluded}
        //an external component
        else if (d.url!==undefined && d.url!='') {return colors.add;}
        //flagged
        else if (d.flag) {return colors.warning}
        //referenced, included
        else if (d.mode===undefined || d.mode=='') {return colors.included;}
        //default
        else {return colors[d.mode];}
}

</script>
